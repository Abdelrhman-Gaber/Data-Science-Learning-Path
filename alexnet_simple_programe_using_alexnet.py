# -*- coding: utf-8 -*-
"""AlexNet- Simple programe using AlexNet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qpeA5BSpGOE63YTk1th9fPLYYcPlJyxP
"""

import tensorflow as tf
from keras_preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(rescale = 1./255,
                                   shear_range = 0.2,
                                   zoom_range = 0.2,
                                   horizontal_flip = True)
training_set = train_datagen.flow_from_directory('data/train',
                                            target_size = (224, 224),
                                            batch_size = 32,
                                            class_mode = 'categorical')
val_datagen = ImageDataGenerator(rescale = 1./255)
val_set = val_datagen.flow_from_directory('data/test',
                                            target_size = (224, 224),
                                            batch_size = 32,
                                            class_mode = 'categorical')

model = tf.keras.models.Sequential()
model.add(tf.keras.layers.Conv2D(filters = 96, input_shape = (224, 224, 3), 
            kernel_size = (11, 11), strides = (4, 4), 
            padding = 'valid'))
model.add(tf.keras.layers.Activation('relu'))
# Max-Pooling 
model.add(tf.keras.layers.MaxPooling2D(pool_size = (2, 2),
            strides = (2, 2), padding = 'valid'))
# Batch Normalisation
model.add(tf.keras.layers.BatchNormalization())
  
# 2nd Convolutional Layer
model.add(tf.keras.layers.Conv2D(filters = 256, kernel_size = (11, 11), 
            strides = (1, 1), padding = 'valid'))
model.add(tf.keras.layers.Activation('relu'))
# Max-Pooling
model.add(tf.keras.layers.MaxPooling2D(pool_size = (2, 2), strides = (2, 2), 
            padding = 'valid'))
# Batch Normalisation
model.add(tf.keras.layers.BatchNormalization())
  
# 3rd Convolutional Layer
model.add(tf.keras.layers.Conv2D(filters = 384, kernel_size = (3, 3), 
            strides = (1, 1), padding = 'valid'))
model.add(tf.keras.layers.Activation('relu'))
# Batch Normalisation
model.add(tf.keras.layers.BatchNormalization())
  
# 4th Convolutional Layer
model.add(tf.keras.layers.Conv2D(filters = 384, kernel_size = (3, 3), 
            strides = (1, 1), padding = 'valid'))
model.add(tf.keras.layers.Activation('relu'))
# Batch Normalisation
model.add(tf.keras.layers.BatchNormalization())
  
# 5th Convolutional Layer
model.add(tf.keras.layers.Conv2D(filters = 256, kernel_size = (3, 3), 
            strides = (1, 1), padding = 'valid'))
model.add(tf.keras.layers.Activation('relu'))
# Max-Pooling
model.add(tf.keras.layers.MaxPooling2D(pool_size = (2, 2), strides = (2, 2), 
            padding = 'valid'))
# Batch Normalisation
model.add(tf.keras.layers.BatchNormalization())
  
# Flattening
model.add(tf.keras.layers.Flatten())
  
# 1st Dense Layer
model.add(tf.keras.layers.Dense(4096, input_shape = (224*224*3, )))
model.add(tf.keras.layers.Activation('relu'))
# Add Dropout to prevent overfitting
model.add(tf.keras.layers.Dropout(0.4))
# Batch Normalisation
model.add(tf.keras.layers.BatchNormalization())
  
# 2nd Dense Layer
model.add(tf.keras.layers.Dense(4096))
model.add(tf.keras.layers.Activation('relu'))
# Add Dropout
model.add(tf.keras.layers.Dropout(0.4))
# Batch Normalisation
model.add(tf.keras.layers.BatchNormalization())
  
# Output Softmax Layer
model.add(tf.keras.layers.Dense(2))
model.add(tf.keras.layers.Activation('softmax'))

model.compile(optimizer = 'adam', loss = 'categorical_crossentropy', metrics = ['accuracy'])

model.fit(x = training_set, validation_data = val_set,batch_size=32, epochs = 10)

import numpy as np
import matplotlib.pyplot as plt
from keras_preprocessing import image
path='data/test/benign/1.jpg'
test_image = image.load_img(path, target_size = (224, 224))
print(test_image)
test_image = image.img_to_array(test_image)
print(test_image)
test_image = np.expand_dims(test_image, axis = 0)
print(test_image)
result = cnn.predict(test_image)
print(result)
training_set.class_indices
z=plt.imread(path)
plt.imshow(z)

if result[0][0] == 1:
  prediction = 'benign'
else:
  prediction = 'malignant'
print(prediction)

